function drawGrid() {
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      const type = grid[r][c];
      if (type === null) continue;

      const x = gridOffsetX + c * SIZE + SIZE / 2;
      const y = gridOffsetY + r * SIZE + SIZE / 2;
      const radius = SIZE * 0.38;

      // === TILE BASE ===
      const baseGradient = ctx.createRadialGradient(
        x, y - radius * 0.3, radius * 0.2,
        x, y, radius
      );
      baseGradient.addColorStop(0, "#1e293b");
      baseGradient.addColorStop(1, "#020617");

      ctx.fillStyle = baseGradient;
      ctx.beginPath();
      ctx.roundRect(
        x - radius,
        y - radius,
        radius * 2,
        radius * 2,
        radius * 0.35
      );
      ctx.fill();

      // === AURORA GLOW ===
      const glowColors = [
        "#34d399", // life
        "#94a3b8", // stone
        "#fb923c", // fire
        "#38bdf8", // water
        "#e5e7eb"  // air
      ];

      ctx.shadowColor = glowColors[type];
      ctx.shadowBlur = 18;

      // === RUNE DRAW ===
      ctx.strokeStyle = glowColors[type];
      ctx.lineWidth = SIZE * 0.09; // ⬅️ SILNEJŠIA HRÚBKA
      ctx.lineCap = "round";
      ctx.lineJoin = "round";

      ctx.beginPath();

      switch (type) {
        case 0: // LIFE – circle rune
          ctx.arc(x, y, radius * 0.45, 0, Math.PI * 2);
          break;

        case 1: // STONE – diamond
          ctx.moveTo(x, y - radius * 0.45);
          ctx.lineTo(x + radius * 0.45, y);
          ctx.lineTo(x, y + radius * 0.45);
          ctx.lineTo(x - radius * 0.45, y);
          ctx.closePath();
          break;

        case 2: // FIRE – flame
          ctx.moveTo(x, y + radius * 0.45);
          ctx.quadraticCurveTo(x + radius * 0.3, y, x, y - radius * 0.45);
          ctx.quadraticCurveTo(x - radius * 0.3, y, x, y + radius * 0.45);
          break;

        case 3: // WATER – wave
          ctx.moveTo(x - radius * 0.45, y);
          ctx.quadraticCurveTo(x, y - radius * 0.35, x + radius * 0.45, y);
          ctx.quadraticCurveTo(x, y + radius * 0.35, x - radius * 0.45, y);
          break;

        case 4: // AIR – spiral
          ctx.arc(x, y, radius * 0.15, 0, Math.PI * 2);
          ctx.moveTo(x + radius * 0.15, y);
          ctx.arc(x, y, radius * 0.35, 0, Math.PI * 1.5);
          break;
      }

      ctx.stroke();

      // reset shadow
      ctx.shadowBlur = 0;
    }
  }
}